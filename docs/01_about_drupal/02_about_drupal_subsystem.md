---
marp: true
theme: gaia
_class: invert
---

<!-- _class: lead -->
# 1.2 Drupalの主要なサブシステム

---

## 1.2.1 Routing

Webアプリケーションの処理の全てはルーティングから始まります。

もし「ルーティング」という言葉に馴染みがない場合、ここで一旦進めるのを止めて意味を調べてみてください(ネットワーク装置のルーティングと混同しないように注意してください)。

それくらい、ルーティングという概念を理解することは重要です。

---

Drupalの処理は特定のパス（またはリソース）にユーザー（またはシステム）がアクセスするところから始まります。

これは、そのリソースをフローにマッピングするルートに変換されます。このフローは、（できれば）成功した​​応答または少なくとも正常な失敗を返します。

Drupal 8のルーティングシステムは、以前のバージョンとは全く別のものに変更されています。

Drupal 7以前では、ルーティングシステムはDrupal独自に開発されたものでした。古いバージョンのDrupalを使ったことのある方であれば `hook_menu` という関数名に馴染みがあると思います。

---

`hook_menu` のことはもう忘れましょう。

Drupal 8では Symfonyの [Routingコンポーネント](http://symfony.com/doc/current/components/routing.html) が採用されました。

Drupalのモジュールでどのようにルーティングを制御するかについては、2章でサンプルコードを交えて解説します。

---

## 1.2.2 Entity

`Entity` はデータをモデリングし、Drupalを制御する非常に強力な方法です。

開発者向けにざっくり説明すると、Ruby on RailsのActiveRecordや、LaravelのEloquent ORMが、DrupalではEntityに当たります(もちろん、厳粛には細部は色々違います)。

Drupal 7以前のバージョンでは、最も有名なタイプのエンティティとしてノードがありました。つまり、Drupal上で管理される各ページのコンテンツ(ノード)は、フレームワーク内部ではEntityとして扱われています。

---

Drupal 8では、Entityシステム全体が刷新され、ユーザー、メニュー、ファイル、設定など、非常に多くのデータがEntityとして管理されるようになりました。

基底クラスである `\Drupal\Core\Entity\Entity` の [派生クラス](https://www.drupal.org/files/classDrupal_Entities.png) を見ると、コアのコードだけでもすごいことになっているのがわかります。

---

すべてのエンティティタイプには、同じタイプの異なるバリエーションである複数のバンドル(`bundle`)を定義することができ、それらに異なるフィールドを含めることができます（一部のベースフィールドを共有することもできます）。

bundleの例として、Drupalコアの `standard` インストールプロファイルには `Basic Page` や `Article` などのいくつかのNodeエンティティのbundleが定義されています。

さらに、`User`, `Comment`, `File` など、いくつかの他のタイプも存在します。

---

独自のEntity Typeを定義する場合、Drupal 7ではcontirbute moduleを追加する必要がありました。Drupal 8では、Entityシステムの全てがコアに含まれており、Drupal 7のEntityより更に標準化されています。

ノードは本来「Webページ」を管理するためのモデルですが、Drupal 7ではその用途を超えて不適切に使われるケースも多くありました。

Drupal 8では、Entityシステムがコアに組み込まれ、コアが提供するほとんどのモデルもEntityとなったため、より適切なモデリングを行うことができます。

---

これまで挙げた例は全てコンテンツエンティティですが、Drupal 8では、コンフィグエンティティも導入されました。

コンテンツエンティティはその名の通り、コンテンツのモデリングに利用されます。データベースに保存され、その環境に固有のデータを保持します。

一方、コンフィグエンティティは複数の環境で共通になるデータを管理します。例えばサイトの設定です。コンフィグエンティティはファイルとしてエクスポート可能であり、他の環境にインポートすることもできます。

---

エンティティシステムを理解することは、カスタムデータとコンテンツをモデル化する強力な方法を提供するため、Drupal 8で開発を行うために不可欠です。

コンテンツエンティティとコンフィグエンティティに関する解説は2章で、エンティティシステム自体の開発は4章(予定)で行います。

---

## 1.2.3 Fields

エンティティが何であるかがわかったので、これらのエンティティに実際にデータが保存される方法を見てみましょう。

前のセクションで、特定のエンティティタイプのバンドルに様々なフィールドを含める方法について言及しました。

つまり、各エンティティタイプのバンドルには、データを保持するフィールドをいくつでも持つことができます。さらに、エンティティタイプ自体に全てのバンドルで共通するフィールドを含めることができます。

---

さて、これを分解しましょう。Drupal 8には、ベースフィールドと設定可能なフィールドの2種類のフィールドがあります。

他のフレームワークの永続化層と比較した時に、Drupalの最も特殊な要素がこの点であり、開発者を悩ませる点です。

ここでしっかりと概念を押さえておきましょう。

---

前者の「ベースフィールド」は各エンティティタイプのコードで定義されるフィールドです。他のフレームワークの例だと、ActiveRecordやEloquent ORMなどを使い、「コードで書かれているモデルクラスの属性」がこれに当たります。

「モデルの属性なんだからモデルクラスのコードで書かれていて当たり前だよね？」と思いましたか？

思った方はこのまま先に進みましょう。

---

面白い（恐ろしい？）ことに、Drupalには「コードで書かれていないモデルの属性」が存在します。これが、後者の「設定可能なフィールド」です。

通常、後者は管理UIから作成および管理され、そのエンティティタイプのバンドルに添付されます。

フィールドは格納するデータに応じて複数のタイプから選択することができます。文字列（またはテキスト）フィールド、数値フィールド、日付フィールド、メールフィールドなどを持つことができます。

既存のフィールドタイプが表現したいデータに対して十分でない場合、独自のフィールドタイプを作成こともできます。

---

4章(予定)では、独自のエンティティタイプでベースフィールドを定義し、データ入力ウィジェットと出力フォーマッターで独自のフィールドタイプを作成する方法を解説します。

---

## 1.2.4 メニュー

Ruby on RailsやLaravelでシステムのメニューを実装する場合、どのようなアプローチを取るでしょうか？

フレームワークではメニューまでは関知しないため、Bootstrapなどでフロントエンドを作ったり、メニューを生成するためのライブラリを導入するのが一般的な手法だと思います

(Laravelは詳しくないので、Laravelの一般的な手法を知っている方は教えてください!)

---

DrupalはCMSとしての利用から発展したフレームワークのため、フレームワークレベルでメニューの管理をサポートしています。つまり、メニューを生成、取得、変更するためのAPIを提供します。

メニューを操作する方法については、2章で詳しく解説します。

---

## 1.2.5 Views

コンテンツとデータの一覧表示は、コンテンツ管理システムにおいて非常に重要な機能です。Drupal 8ではViewsがこれを行います。Viewsは元はcontribute moduleでしたが、Drupal 8からコアに含まれました。

Viewsの目的は、データとコンテンツを管理UIから(もちろんコードからも)構成可能なリストの作成という方法で公開することです。これには、フィルター、並べ替え、表示オプション、その他の多くの機能などが含まれます。

開発者向けに一言で説明するなら「UIの自動生成機能が付いたSQLビルダー」です。

---

Viewsを活用すれば、Drupalでの開発において「検索機能付きのデータの一覧」(業務系のシステムだとよく書きますよね)のようなものをコードで書く必要はほぼありません。

例えば、`standard` インストールプロファイルに含まれているコンテンツの一覧 (`/admin/content`) やユーザーの一覧 (`/admin/people`) はViewsで作られています。

逆にViewsで生成した一覧に対してビジネスロジックで必要な操作をしたり、カスタムエンティティまたは外部のデータソースを参照するような場合は、独自のフィールドまたはフィルタープラグインを作成する必要があることがあります。

Viewsを拡張するPluginの実装については、5章(予定)で解説します。

---

## 1.2.6 Forms

ある程度の規模のシステムでは、何らかの形式でユーザー入力を受け取る必要がある可能性は非常に高くなります。

PHP(に限らずプログラミング言語)の標準機能だけでフォームを実装した事がある方は、送信されたデータを安全かつ効率的にレンダリングおよび処理するのは意外に難易度が高いことをご存知だと思います。

SymfonyやLaravelなどのPHPフレームワーク(もちろんRuby on RailsやDjangoでも同じです)を使用するとすぐに、その負荷の多くを肩代わりするAPIが用意されていることに気付くでしょう。

---

Drupal 8とその強力なForm APIでも同じことが言えます。歴史的には、独自のフォーム要素を出力し、投稿された値を処理する必要があるということについて、非常に抽象化されてきました。OOPで独自のフォーム定義を定義し、論理的な方法で検証と送信を処理できます。

そのレンダリングと処理はDrupalによって安全に処理されるため、そのことを心配する必要はありません。 Drupal 8では、テーマのフォーム要素が以前のバージョンよりもはるかに簡単になりました。

Form APIのサンプルについては、5章(予定)で解説します。

---

## 1.2.7 Configuration

Drupal開発者（および他の人気のあるCMSの開発者）が求める主要な機能の1つに、ある環境から別の環境(例: dev -> stg -> prodなど)への設定の移行があります。

Drupal 7では設定のほとんどはデータベースに保存されており、別環境への移行は標準機能ではサポートされていませんでした。代わりに、開発者は [Features](https://www.drupal.org/project/features) などのcontribute moduleを使ってこの問題を解決していました。

---

Drupal 8では、コアの機能として構成(設定)管理がサポートされています。

すべての構成をデータベースに保存しますが、ymlファイルでエクスポートおよびインポートすることができます。

(ちなみに、設定を常にymlファイルからR/Wするように変更することもできます)

従って、ymlファイルをgit等で管理することによって、別の環境への設定の移行が実現できます。

この機能については2章で詳しく解説します。

---

## 1.2.8 Plugins

プラグインはDrupal 8の新たな機能であり、ビジネスロジックのカプセル化を実現するソリューションです。

本コンテンツ(および多くの外部のコンテンツでも)で `Plugin(s)`(Pが大文字)という言葉が使われている場合は、一般的な「機能を追加する仕組み」ではなく、Drupal独自の `Plugin` という仕組みについて説明している、という点に注意してください。

---

Pluginの重要な側面は、発見可能(Discoverability)であることです。

ほとんどのプラグインは、アノテーションを介して検出されます。

アノテーションは [Doctrine](http://docs.doctrine-rine-project.org/projects/doctrine-common/en/latest/reference/annotations.html) の機能を使った[DocBlock](https://docs.phpdoc.org/latest/guides/docblocks.html)のコメントであり、これによりクラス、メソッド、プロパティなどを正確なメタデータとして記述できます。

メタデータを読み込むことで、クラスをインスタンス化することなく、どんな機能が提供されているかを判断できるようになります。

---

プラグインは、開発者が独自の機能を追加するためのフックに代わる新しい拡張ポイントであり、Drupal 8の非常に重要なサブシステムです。

プラグインについての詳しい解説は2章で行います。

---

## 1.2.9 The theme system

あるデータを出力するための責任は、Drupalコア、モジュール、テーマそれぞれに分散しています。

そのため、モジュールとテーマの両方がデータをテーマ化できることを知ることが重要です。

Themingという概念はテーマだけのものではない、ということをモジュール開発者、テーマ開発者の双方が理解しておく必要があります。

モジュールによるコンポーネント単位のテーマ実装や、テーマ自体の実装については3章(予定)で解説します。

---

通常は、モジュールがデータのテーマを設定できるようにすることをお勧めします。

適切に実装された場合、テーマは出力のスタイルを設定したり、そのテーマをオーバーライドしてプレゼンテーション層全体を変更したりすることができます。

古いバージョンと比較したDrupal 8の大きな変化は、[Twigテンプレートシステム](https://twig.sensiolabs.org/) への移行です。

これにより、ロジックが明確にテンプレートから分離され、より安全なシステムを実装することができます。

---

## 1.2.10 Caching

---

開発者の観点から見ると、キャッシングシステムには2つの主な要素があります。

1つ目は、複雑なデータ計算の結果を保存するキャッシュバックエンドを開発者に提供することです。

一度キャッシュしてしまえば、それを次のリクエストで読み取ることができ、そのタスクを再処理する必要がなくなります。

これは、計算のやり直しを必要とするシステム内の要素が変更されたときに発生するキャッシュの無効化と連動します。

---

2つ目はレンダーキャッシュです。これにより、開発者は出力のキャッシュをいつ無効にする必要があるかを記述するメタデータで出力をラップできます。これらの動作については5章(予定)で解説します。

---

## 1.2.11 Other subsystems

Drupal 8には他にもサブシステムが存在しますが、ここでの紹介は割愛します。

---

## まとめ

このセクションではDrupalの主要なサブシステムの概要について解説しました。

各サブシステムの詳細な解説は、必要に応じて以降で随時行います。
