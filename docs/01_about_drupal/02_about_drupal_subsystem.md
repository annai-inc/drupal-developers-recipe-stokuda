---
marp: true
theme: gaia
_class: invert
---

<!-- _class: lead -->
# 1.2 Drupalの主要なサブシステム

---

## 1.2.1 Routing

Webアプリケーションの処理の全てはルーティングから始まります。
もし「ルーティング」という言葉に馴染みがない場合、ここで一旦進めるのを止めて意味を調べてみてください(ネットワーク装置のルーティングと混同しないように注意が必要です)。

それくらい、ルーティングという概念を理解することは重要です。

---

Drupalの処理は特定のパス（またはリソース）にユーザー（またはシステム）がアクセスするところから始まります。

これは、そのリソースをフローにマッピングするルートに変換されます。このフローは、（できれば）成功した​​応答または少なくとも正常な失敗を返します。

Drupal 8のルーティングシステムは、以前のバージョンで使用されていた方法から大きくシフトしています。

Drupal 7以前では、ルーティングシステムはDrupal独自に開発されたものでした。古いバージョンのDrupalを使ったことのある方であれば `hook_menu` という関数名に馴染みがあると思います。

---

`hook_menu` のことはもう忘れましょう。

Drupal 8では Symfonyの [Routingコンポーネント](http://symfony.com/doc/current/components/routing.html) が採用されました。

Drupalのモジュールでどのようにルーティングを制御するかについては、2章でサンプルコードを交えて解説します。

---

## 1.2.2 Entity

`Entity` はデータをモデリングし、Drupalを制御する非常に強力な方法です。

開発者向けにざっくり説明すると、Ruby on RailsのActiveRecordや、LaravelのEloquent ORMが、DrupalではEntityに当たります(もちろん、厳粛にはかなり違います)。

Drupal 7以前のバージョンでは、最も有名なタイプのエンティティとしてノードがありました。つまり、Drupal上で管理される各ページのコンテンツ(ノード)は、フレームワーク内部ではEntityとして扱われています。

---

Drupal 8では、Entityシステム全体が刷新され、ユーザー、メニュー、ファイル、設定など、非常に多くのデータがEntityとして管理されるようになりました。

基底クラスである `\Drupal\Core\Entity\Entity` の [派生クラス](https://www.drupal.org/files/classDrupal_Entities.png) を見ると、コアのコードだけでもすごいことになっているのがわかります。

---

すべてのエンティティタイプには、同じタイプの異なるバリエーションである複数のバンドル(`bundle`)を含めることができ、それらに異なるフィールドを含めることができます（一部のベースフィールドを共有することもできます）。

bundleの例として、Drupalコアの `standard` インストールプロファイルには `Basic Page` や `Article` などのいくつかのbundleが含まれたNodeエンティティタイプが定義されています。

さらに、`User`, `Comment`, `File` など、いくつかの他のタイプも存在します。

---

独自のEntity Typeを定義する場合、Drupal 7ではcontirbute moduleを追加する必要がありました。Drupal 8では、Entityシステムの全てがコアに含まれており、Drupal 7のEntityより更に標準化されています。

Drupal 8に存在するエンティティのタイプはこれらだけではありません。前述の例はすべてコンテンツエンティティタイプです。

ただし、Drupal 8では、構成エンティティタイプも導入されました。前者はコンテンツのモデリング用ですが、実際には、データベースに保存でき、その環境に固有のデータを保持するものです。

ただし、構成の保存には使用されません。ユーザーとコンテンツは、ある環境から別の環境に（通常）展開する必要がないため、素晴らしい例です。

---

一方、後者は構成のエクスポート可能なアイテムであり、複数存在する場合があります。

たとえば、特定のエンティティタイプには複数のバンドルが存在する可能性があるため、コンテンツエンティティバンドルは素晴らしい例です。

バンドルごとに異なるメタデータと情報が保存されており、すべての環境に展開する必要があります。

つまり、これらはサイトが正しく機能するための基本です。

---

エンティティシステムを理解することは、カスタムデータとコンテンツをモデル化する強力な方法を提供するため、Drupal 8で開発を行うために不可欠です。

ノードはジョブの唯一のツールではなく、適切なエンティティアーキテクチャがないため、以前のDrupalバージョンでは目的を超えて使用されていました。

---

## 1.2.3 Fields

エンティティが何であるかがわかったので、これらのエンティティに実際にデータが保存される方法を見てみましょう。

前のセクションで、特定のエンティティタイプのバンドルに様々なフィールドを含める方法について言及しました。

つまり、各エンティティタイプのバンドルには、データを保持するフィールドをいくつでも持つことができます。さらに、各エンティティタイプ自体に、データを格納するフィールドを含めることができます。

---

さて、これを分解しましょう。Drupal 8には、ベースフィールドと設定可能なフィールドの2種類のフィールドがあります。

他のフレームワークの永続化層と比較した時に、Drupalの最も特殊な要素がこの点であり、開発者を悩ませる点です。

ここでしっかりと概念を押さえておきましょう。

---

前者の「ベースフィールド」は各エンティティタイプのコードで定義されるフィールドです。他のフレームワークの例だと、ActiveRecordやEloquent ORMなどを使い、「コードで書かれているモデルクラスの属性」がこれに当たります。

「モデルの属性なんだからモデルクラスのコードで書かれていて当たり前だよね？」と思いましたか？

思った方は十分にシステム開発の経験があります。このまま先に進みましょう。

---

面白い（恐ろしい？）ことに、Drupalには「コードで書かれていないモデルクラスの属性」が存在します。これが、後者の「設定可能なフィールド」です。

後者は通常は管理UIから作成および管理され、そのエンティティタイプのバンドルに添付されます（および構成を介してエクスポートされます）。

フィールドは格納するデータに応じて、複数のタイプにすることもできます。文字列（またはテキスト）フィールド、数値フィールド、日付フィールド、電子メールフィールドなどを持つことができます。開発者として、既存のフィールドタイプがデータに対して十分でない場合、独自のフィールドタイプを作成できます。

---

4章(予定)では、独自のエンティティタイプでベースフィールドを定義し、データ入力ウィジェットと出力フォーマッタで独自のフィールドタイプを作成する方法を解説します。

---

## 1.2.4 メニュー

Ruby on RailsやLaravelでシステムのメニューを実装する場合、どのようなアプローチを取るでしょうか？

フレームワークではメニューまでは関知しないため、Bootstrapなどでフロントエンドを作ったり、メニューを生成するためのライブラリを導入するのが一般的な手法だと思います (Laravelは詳しくないので、一般的な手法を知っている方は教えてください!)

---

DrupalはCMSとしての利用から発展したフレームワークのため、フレームワークレベルでメニューの管理をサポートしています。つまり、メニューを生成、取得、変更するためのAPIを提供します。

メニューを操作する方法については、2章で詳しく解説します。

---

## 1.2.5 Views

コンテンツとデータの一覧表示は、コンテンツ管理システムにおいて非常に重要な機能です。Drupal 8ではViewsがこれを行います。Viewsは元はcontribute moduleでしたが、Drupal 8からコアに含まれました。

Viewsの目的は、データとコンテンツを管理UIから(もちろんコードからも)構成可能なリストの作成という方法で公開することです。これには、フィルター、並べ替え、表示オプション、その他の多くの機能などが含まれます。

開発者向けに一言で説明するなら「UIの自動生成機能が付いたSQLビルダー」です。

---

Viewsを活用すれば、Drupalでの開発において「検索機能付きのデータの一覧」(業務系のシステムだとよく書きますよね)のようなものをコードで書く必要はほぼありません。

例えば、`standard` インストールプロファイルに含まれているコンテンツの一覧 (`/admin/contents`) やユーザーの一覧 (`/admin/people`) はViewsで作られています。

逆にViewsで生成した一覧に対してビジネスロジックで必要な操作したり、カスタムエンティティまたは外部のデータソースを参照するような場合は、独自のフィールドまたはフィルタープラグインを作成する必要があることがよくあります。

Viewsを拡張するPluginの実装については、5章(予定)で解説します。

---

## 1.2.6 Forms

ある程度の規模のシステムでは、何らかの形式でユーザー入力を受け取る必要がある可能性は非常に高くなります。

PHP(に限らずプログラミング言語)の標準機能だけでフォームを実装した事がある方は、送信されたデータを安全かつ効率的にレンダリングおよび処理するのは意外に難易度が高いことをご存知だと思います。

SymfonyやLaravelなどのPHPフレームワーク(もちろんRuby on RailsやDjangoでも同じです)を使用するとすぐに、その負荷の多くを肩代わりするAPIが用意されていることに気付くでしょう。

---

Drupal 8とその強力なForm APIでも同じことが言えます。歴史的には、独自のフォーム要素を出力し、投稿された値を処理する必要があるということについて、非常に抽象化されてきました。OOPで独自のフォーム定義を定義し、論理的な方法で検証と送信を処理できます。

そのレンダリングと処理はDrupalによって安全に処理されるため、そのことを心配する必要はありません。 Drupal 8では、テーマのフォーム要素が以前のバージョンよりもはるかに簡単になりました。

Form APIのサンプルについては、5章(予定)で解説します。

---

## 1.2.7 Configuration

Drupal開発者（および他の人気のあるCMSの開発者）が求める主要な機能の1つに、ある環境から別の環境(例: dev -> stg -> prodなど)への設定の移行があります。

Drupal 7では設定のほとんどはデータベースに保存されており、別環境への移行は標準機能ではサポートされていませんでした。代わりに、開発者は [Features](https://www.drupal.org/project/features) などのcontribute moduleを使ってこの問題を解決していました。

---

Drupal 8では、コアの機能として構成(設定)管理がサポートされています。

すべての構成をデータベースに保存しますが、ymlファイルでエクスポートおよび再インポートすることができます。

(ちなみに、設定を常にymlファイルからR/Wするように変更することもできます)

従って、ymlファイルをgit等で管理することによって、別の環境への設定の移行が実現できます。

---

## 1.2.8 Plugins

プラグインはDrupal 8の新たな機能であり、ビジネスロジックのカプセル化に対するエレガントなソリューションです。

本コンテンツ(および多くの外部のコンテンツでも)で `Plugin(s)`(Pが大文字)という言葉が使われている場合は、「一般的な機能を追加する仕組み」ではなく、Drupal独自の `Plugin` という仕組みについて説明している、という点に注意してください。

---

通常、システムが特定の方法でタスクを処理する場合（プラグインA）に使用されますが、他のモジュールがそのタスク（プラグインBまたはC）を処理するための異なる方法を提供できる場合に使用されます。

また、プラグインはエンティティの反対側にあると見なすこともできます。データストレージではなく機能のために使用されます。保存されるタイプのデータを作成する代わりに、使用されるタイプの機能を作成します。

特に、データをさまざまな方法で操作する場合、この2つは通常は連携して機能します。

---

Pluginの重要な側面は、発見可能(Discoverability)であることです。

ほとんどのプラグインタイプ（ただしすべてではありません）は、アノテーションを介して検出されます。

アノテーションは、[Doctrine](http://docs.doctrine-rine-project.org/projects/doctrine-common/en/latest/reference/annotations.html) の機能を使ったDocBlockのコメントであり、これによりクラス、メソッド、プロパティなどを正確なメタデータとして記述できます。

メタデータを読み込むことで、クラスをインスタンス化することなく、そのアイテムが何であるかを判断できるようになります。

---

Drupal 8では、特定の特性を備えたプラグイン実装であることを示すために、クラスレベルでのみ注釈を使用します。

これが、ほとんどのプラグインがDrupal 8で発見される方法です。

---

プラグインの2番目に発見方法は、yamlファイルで定義をすることです。
Drupalの実装では、メニューリンクなどでこの実装が利用されています。

しかし、今では、プラグインが非常に広く使用されていることを知っておく必要があります。この本では、プラグイン用にかなり作成します。

プラグインは、開発者が独自の機能を追加するための優れた新しい拡張ポイントであり、Drupal 8の重要なサブシステムです。

すべてのDrupal 8開発者は、プラグインシステムに慣れている必要があります。

---

## 1.2.9 The theme system

あるデータを出力するための責任は、Drupalコア、モジュール、テーマそれぞれに分散しています。

そのため、モジュール開発者として、モジュールとテーマの両方がデータまたはコンテンツをテーマ化できることを知ることが重要です。

モジュールによるコンポーネント単位のテーマ実装や、テーマ自体の実装については3章(予定)で解説します。

---

通常は、モジュールがデータのテーマを設定できるようにすることをお勧めします。

適切に行われた場合、テーマは、出力のスタイルを設定したり、そのテーマをオーバーライドしてプレゼンテーション全体を変更したりすることができます。

古いバージョンと比較したDrupal 8の大きな変化は、[Twigテンプレートシステム](https://twig.sensiolabs.org/) への移行です。

これにより、ロジックが明確にテンプレートから分離され、より安全なシステムを実装することができます。

---

## 1.2.10 Caching

Drupal 8は、ページの構築とデータのレンダリングのパフォーマンスを改善するために、非常に長い時間をかけてきました。

この目的のために、キャッシングシステムは、複雑な計算や重い計算を行ったり、コンテンツをレンダリングしたりする際に考慮すべき重要な部分になりました。

---

モジュール開発者の観点から見ると、キャッシングシステムには2つの主な要素があります。

1つ目は、複雑なデータ計算の結果を保存するキャッシュバックエンドを開発者に提供します。

一度キャッシュしてしまえば、それを　次のリクエストで読み取ることができ、そのタスクを再処理する必要がなくなります。

これは、計算のやり直しを必要とするシステム内の何かが変更されたときに発生するキャッシュの無効化と連動します。

---

2つ目はレンダーキャッシュです。これにより、開発者は出力のキャッシュをいつ無効にする必要があるかを記述するメタデータで出力をラップできます。これらの動作については5章(予定)で解説します。

---

## 1.2.11 Other subsystems

Drupal 8には、他にもサブシステムが存在しますが、ここでの紹介は割愛し、以降の章で必要に応じて紹介していきます。

---

## まとめ

このセクションではDrupalの主要なサブシステムの概要について解説しました。

各サブシステムの詳細な解説は、必要に応じて以降で随時行います。
