---
marp: true
theme: gaia
_class: invert
---

<!-- _class: lead -->
# Drupalの主要なサブシステム

---

## Routing

Webアプリケーションの処理の全てはルーティングから始まります。
もし「ルーティング」という言葉に馴染みがない場合、ここで一旦進めるのを止めて意味を調べてみてください(ネットワーク装置のルーティングと混同しないように注意が必要です)。

それくらい、ルーティングという概念を理解することは重要です。

---

Drupalの処理は特定のパス（またはリソース）にユーザー（またはシステム）がアクセスするところから始まります。

これは、そのリソースをフローにマッピングするルートに変換されます。このフローは、（できれば）成功した​​応答または少なくとも正常な失敗を返します。

Drupal 8のルーティングシステムは、以前のバージョンで使用されていた方法から大きくシフトしています。

Drupal 7以前では、ルーティングシステムはDrupal独自に開発されたものでした。古いバージョンのDrupalを使ったことのある方であれば `hook_menu` という関数名に馴染みがあると思います。

---

`hook_menu` のことはもう忘れましょう。
Drupal 8では Symfonyの [Routingコンポーネント](http://symfony.com/doc/current/components/routing.html) が採用されました。

Drupalのモジュールでどのようにルーティングを制御するかについては、3章でサンプルコードを交えて解説します。

---

## Entity

`Entity` はデータをモデリングし、Drupalを制御する非常に強力な方法です。

開発者向けにざっくり説明すると、Ruby on RailsのActiveRecordや、LaravelのEloquent ORMが、DrupalではEntityに当たります(もちろん、厳粛にはかなり違います)。

Drupal 7以前のバージョンでは、最も有名なタイプのエンティティとしてノードがありました。つまり、Drupal上で管理される各ページのコンテンツ(ノード)は、フレームワーク内部ではEntityとして扱われています。

---

Drupal 8では、Entityシステム全体が刷新され、ユーザー、メニュー、ファイル、設定など、非常に多くのデータがEntityとして管理されるようになりました。

基底クラスである `\Drupal\Core\Entity\Entity` の [派生クラス](https://www.drupal.org/files/classDrupal_Entities.png) を見ると、コアのコードだけでもすごいことになっているのがわかります。

---

すべてのエンティティタイプには、同じタイプの異なるバリエーションである複数のバンドル(`bundle`)を含めることができ、それらに異なるフィールドを含めることができます（一部のベースフィールドを共有することもできます）。

bundleの例として、Drupalコアの `standard` インストールプロファイルには `Basic Page` や `Article` などのいくつかのbundleが含まれたNodeエンティティタイプが定義されています。

さらに、`User`, `Comment`, `File` など、いくつかの他のタイプも存在します。

---

独自のEntity Typeを定義する場合、Drupal 7ではcontirbute moduleを追加する必要がありました。Drupal 8では、Entityシステムの全てがコアに含まれており、Drupal 7のEntityより更に標準化されています。

Drupal 8に存在するエンティティのタイプはこれらだけではありません。前述の例はすべてコンテンツエンティティタイプです。

ただし、Drupal 8では、構成エンティティタイプも導入されました。前者はコンテンツのモデリング用ですが、実際には、データベースに保存でき、その環境に固有のデータを保持するものです。

ただし、構成の保存には使用されません。ユーザーとコンテンツは、ある環境から別の環境に（通常）展開する必要がないため、素晴らしい例です。

---

一方、後者は構成のエクスポート可能なアイテムであり、複数存在する場合があります。

たとえば、特定のエンティティタイプには複数のバンドルが存在する可能性があるため、コンテンツエンティティバンドルは素晴らしい例です。

バンドルごとに異なるメタデータと情報が保存されており、すべての環境に展開する必要があります。

つまり、これらはサイトが正しく機能するための基本です。

---

エンティティシステムを理解することは、カスタムデータとコンテンツをモデル化する強力な方法を提供するため、Drupal 8で開発を行うために不可欠です。

ノードはジョブの唯一のツールではなく、適切なエンティティアーキテクチャがないため、以前のDrupalバージョンでは目的を超えて使用されていました。

---

## Fields

エンティティが何であるかがわかったので、これらのエンティティに実際にデータが保存される方法を見てみましょう。

前のセクションで、特定のエンティティタイプのバンドルに様々なフィールドを含める方法について言及しました。

つまり、各エンティティタイプのバンドルには、データを保持するフィールドをいくつでも持つことができます。さらに、各エンティティタイプ自体に、データを格納するフィールドを含めることができます。

---

さて、これを分解しましょう。Drupal 8には、ベースフィールドと設定可能なフィールドの2種類のフィールドがあります。

他のフレームワークの永続化層と比較した時に、Drupalの最も特殊な要素がこの点であり、開発者を悩ませる点です。

ここでしっかりと概念を押さえておきましょう。

---

前者の「ベースフィールド」は各エンティティタイプのコードで定義されるフィールドです。他のフレームワークの例だと、ActiveRecordやEloquent ORMなどを使い、「コードで書かれているモデルクラスの属性」がこれに当たります。

「モデルの属性なんだからコードで書かれていて当たり前だよね？」と思いましたか？

思った方は十分にシステム開発の経験があります。このまま先に進みましょう。

---

面白い（恐ろしい？）ことに、Drupalには「コードで書かれていないモデルクラスの属性」が存在します。これが、後者の「設定可能なフィールド」です。

後者は通常は管理UIから作成および管理され、そのエンティティタイプのバンドルに添付されます（および構成を介してエクスポートされます）。

フィールドは、格納するデータに応じて、複数のタイプにすることもできます。文字列（またはテキスト）フィールド、数値フィールド、日付フィールド、電子メールフィールドなどを持つことができます。開発者として、既存のフィールドタイプがデータに対して十分でない場合、独自のフィールドタイプを作成できます。

---

(TBD)章では、独自のエンティティタイプでベースフィールドを定義し、データ入力ウィジェットと出力フォーマッタで独自のフィールドタイプを作成する方法を解説します。

---

## メニュー

Ruby on RailsやLaravelでシステムのメニューを実装する場合、どのようなアプローチを取るでしょうか？

フレームワークではメニューまでは関知しないため、Bootstrapなどでフロントエンドを作ったり、メニューを生成するためのライブラリを導入するのが一般的な手法だと思います (Laravel詳しい方、教えてください)

---

DrupalはCMSとしての利用から発展したフレームワークのため、フレームワークレベルでメニューの管理をサポートしています。つまり、メニューを生成、取得、変更するためのAPIを提供します。

メニューを操作する方法については、3章で詳しく解説します。